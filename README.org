* =ncurses= (New Curses) tutorial

** C verison

*** How to configure

#+BEGIN_SRC bash
  cd c
  ./configure.sh
#+END_SRC


*** How to run

#+BEGIN_SRC bash
  # Compile `src/main.c and run it`
  cd c
  ./run.sh

  # Compile `src/main_test.c and run it`
  cd c
  ./run_test.sh
#+END_SRC


** Hare version

*** How to run

Make sure to link to the =ncursesw= (wide character supported) library!!!

#+BEGIN_SRC bash
  cd hare
  ./run.sh src/window_border_example.ha
  ./run.sh src/typing_example.ha
#+END_SRC


** Zig version

*** How to run

#+BEGIN_SRC bash
  #
  # Print out supported demo run steps
  #
  zig build --help | rg "run-"
  #  run-typing-example           Run typing-example
  #  run-window-border-example    Run window-border-example

  #
  # Then pick one you like to run it
  #
  zig build run-window-border-example
#+END_SRC


** What is =ncurses=

Here is the info comes from =man ncurses=:

The =ncurses= library routines give the user a terminal-independent method of updating character screens with reasonable optimization. This implementation is =new curses (ncurses)= and is the approved replacement for =4.4BSD= classic =curses=, which has been discontinued.

This describes ncurses version 6.4 (patch 20230520).

The =ncurses= library emulates the =curses= library of System V Release 4 UNIX, and XPG4 (X/Open Portability Guide) =curses= (also known as =XSI curses=). =XSI= stands for =X/Open System Interfaces Extension=.

The =ncurses= library is freely redistributable in source form. Differences from the SVr4 curses are summarized under the EXTENSIONS and PORTABILITY sections below and described in detail in the respective EXTENSIONS, PORTABILITY and BUGS  sections of individual man pages.

The =ncurses= library also provides many useful extensions, i.e., features which cannot be implemented by a simple add-on library but which require access to the internals of the library.

A program using these routines must be linked with the =-lncurses= option, or (if it has been generated) with the debugging library =-lncurses_g=. (Your system integrator may also have installed these libraries under the names =-lcurses= and =-lcurses_g=.) The =ncurses_g= library generates trace logs (in a file called “trace” in the current directory) that describe =curses= actions.

The =ncurses= package supports:

- Overall screen, window and pad manipulation;
- Output to windows and pads;
- reading terminal input;
- Control over terminal and curses input and output options;
- Environment query routines;
- Color manipulation;
- Use of soft label keys;
- Terminfo capabilities;
- And access to low-level terminal-manipulation routines.


** Install

*** Arch Linux

#+BEGIN_SRC bash
  doas pacman --sync --info ncurses
#+END_SRC


** Basic hello world

#+BEGIN_SRC c
  #include <ncurses.h>

  int main() {
      initscr();
      mvwprintw(stdscr,
                0,
                0,
                "Hello world from ncurses");
      // Press any key to exit.
      getch();
      endwin();
  }
#+END_SRC


=initscr()= Create and init the main window (filled with the entire terminal screen) and return its pointer. Also, the return pointer points to the global variable =stdscr=.

=mvprintw()= Move the cursor to the given position and print content to the given window.

=getch()= Block and wait the user to type a single character in the given window (=stdscr= in this case) and return it's value, it causes the given window to refresh/redraw.

=endwin()= The program must also call =endwin= for each terminal being used before exiting from curses. 

All functions without the =w= prefix (e.g. =getch=, =printw=, =refresh()=, etc) are just a wrapped version of with =w= prefix (e.g. =wgetch=, =wprintw=, =wrefresh=, etc) by passing the =stdscr= as the first parameter!!!


** Unicode support

A few steps to support drawing unicode:

1. Add =#include <locale.h>=

2. Call =setlocale(LC_ALL, "");= before =initscr()=

3. Use =%lc= or =%ls= to in the =printw= (or any variant functions)

4. Optionally, if you want to call any =wide char= related funcitons (with a =w= prefix) e.g =addwstr=, you MUST define the =_XOPEN_SOURCE_EXTENDED= macro to compile your program.

   Here is a sample setting to put into your CMake:

   #+BEGIN_SRC cmake
     target_compile_definitions("${PROJECT_NAME}" PRIVATE _XOPEN_SOURCE_EXTENDED)
   #+END_SRC


But keep that in mind, any =not wide char= related functions (witout a =w= prefix) e.g =wborder/addch/etc= don't support unicode!!! (It draws nothing to the terminal)


Example:

#+BEGIN_SRC c
  #include <locale.h>
  #include <ncurses.h>

  int main() {
      setlocale(LC_ALL, "");
      initscr();

      move(2,2);
      wprintw(stdscr, "Unicode symboles: %lc, %lc", L'╝', L'╮');

      move(4,2);
      addstr("╝");
      addstr("┏━┓");

      // Press any key to exit.
      getch();
      endwin();

      return 0;
  }
#+END_SRC


*** =setlocale= for =zig=

Depends on different =lib= implementations you're using, =setlocale= will check the environment variable =LC_ALL= is inspected, next the environment variable with the same name as the category, and finally the environment variable =LANG=. The first existing environment variable is used.  If its value is not a valid locale specification, the locale is unchanged, and =setlocale()= returns =NULL=.

Becuase =zig= compile its =libc= on the fly, =setlocale= returns =C= (The locale =C= or =POSIX= is a portable locale; it exists on all conforming systems), it causes the UTF8 icon can't be drawn, you have to set =LC_ALL= to =en_US.UTF-8= like this to make it work:

#+BEGIN_SRC zig
  //
  // Enable UTF8 support
  //
  _ = nc.setlocale(nc.LC_ALL, "en_US.UTF-8");
#+END_SRC


** =Window=

You can run =man curs_window= to get more detailed information

*** Related functions

#+BEGIN_SRC bash
     newwin
         Calling newwin creates and returns a pointer to a new window with the given number of lines and columns.  The upper left-hand corner of the window is at
                line begin_y,
                column begin_x

         If either nlines or ncols is zero, they default to
                LINES - begin_y and
                COLS - begin_x.

         A new full-screen window is created by calling newwin(0,0,0,0).

         Regardless  of the function used for creating a new window (e.g., newwin, subwin, derwin, newpad), rather than a duplicate (with dupwin), all of the window modes are initialized to the default values.  These functions set window
         modes after a window is created:

                idcok, idlok, immedok, keypad, leaveok, nodelay, scrollok, setscrreg, syncok, wbkgdset, wbkgrndset, and wtimeout

     delwin
         Calling delwin deletes the named window, freeing all memory associated with it (it does not actually erase the window's screen image).  Subwindows must be deleted before the main window can be deleted.

     mvwin
         Calling mvwin moves the window so that the upper left-hand corner is at position (x, y).  If the move would cause the window to be off the screen, it is an error and the window is not moved.  Moving subwindows  is  allowed,  but
         should be avoided.

     subwin
         Calling  subwin  creates and returns a pointer to a new window with the given number of lines, nlines, and columns, ncols.  The window is at position (begin_y, begin_x) on the screen.  The subwindow shares memory with the window
         orig, so that changes made to one window will affect both windows.  When using this routine, it is necessary to call touchwin or touchline on orig before calling wrefresh on the subwindow.

     derwin
         Calling derwin is the same as calling subwin, except that begin_y and begin_x are relative to the origin of the window orig rather than the screen.  There is no difference between the subwindows and the derived windows.

         Calling mvderwin moves a derived window (or subwindow) inside its parent window.  The screen-relative parameters of the window are not changed.  This routine is used to display different parts of the parent window  at  the  same
         physical position on the screen.

     dupwin
         Calling dupwin creates an exact duplicate of the window win.

     wsyncup
         Calling wsyncup touches all locations in ancestors of win that are changed in win.  If syncok is called with second argument TRUE then wsyncup is called automatically whenever there is a change in the window.

     wsyncdown
         The wsyncdown routine touches each location in win that has been touched in any of its ancestor windows.  This routine is called by wrefresh, so it should almost never be necessary to call it manually.

     wcursyncup
         The routine wcursyncup updates the current cursor position of all the ancestors of the window to reflect the current cursor position of the window.

  RETURN VALUE

#+END_SRC


*** Creating, drawing and updating window 

You can use =newwin= to create a new window separated from the main window created by =initscr=.

Here is the a few thing you need to know when working with =newwin=:

**** Call =refresh= or =wrefresh(stdscr)= after =newwin= to notify that a new window has been created.

#+BEGIN_SRC c
    WINDOW *win = newwin(win_height, win_width, win_top, win_left);
    refresh();
#+END_SRC

If don't do that and you don't have another function call to trigger =refresh()=, then you won't see the newly created window even you have called =wprintw= on that window!!!


**** Update/redraw window

When you call =wprintw= with the given window, it updates the memory data without drawing anything to the terminal screen, you need to call =wrefresh= to draw to the terminal screen.

Because =wprintw= only affects the memory data, that's why you can call =wprintw= many times and then follow by a =wrefresh= to push all drawing to the terminl screen for getting better drawing performance.

=wrefresh= only redraw the different/updated area, but there is a =redraw= function for you to force the entire window to be redrawn.

#+BEGIN_SRC c
  // Create a new window
  const popup_window = create_popup_window(screen_width, screen_height);
  wrefresh(stdscr);

  //
  // Draw once after all `wprintw` calls have been done.
  //
  mvwprintw(popup_window, ...);
  mvwprintw(popup_window, ...);
  mvwprintw(popup_window, ...);
  wrefresh(popup_window);
#+END_SRC


**** About closing or destroying the created window

Because =delwin= deletes the named window, freeing all memory associated with it, but it DOES NOT actually erase the window's screen image. That said the previously drawn window content is still there like a bug!!!

That's why you have to either:

1. Call =wclear()= and =wrefresh()= before =delwin()=.

2. Call =redrawwin(parent_window)= after =delwin()= to update the parent window on screen.


#+BEGIN_SRC c
  // Create a new window
  const popup_window = create_popup_window(screen_width, screen_height);

  //
  // Draw once after all `wprintw` calls have been done.
  //
  mvwprintw(popup_window, ...);
  mvwprintw(popup_window, ...);
  mvwprintw(popup_window, ...);
  wrefresh(popup_window);

  //
  // Press a key to destory the popup window
  //
  wgetch(popup.win);
  wclear(popup.win);    // Do this before `delwin`
  wrefresh(popup.win);  // Do this before `delwin`
  delwin(popup_window);

  // redrawwin(stdscr); // Or do this after `delwin`
#+END_SRC


*** Getting window size and rect

#+BEGIN_SRC c
  typedef struct WindowSize {
      int width;
      int height;
  } WindowSize;

  WindowSize get_window_size(const WINDOW *win) {
      int window_width, window_height;
      getmaxyx(win, window_height, window_width);
      return (WindowSize){.width = window_width, .height = window_height};
  }

  typedef struct {
      int left;
      int top;
      int width;
      int height;
  } WindowRect;

  WindowRect get_window_rect(const WINDOW *win) {
      return (WindowRect){
          .left   = getbegx(win),
          .top    = getbegy(win),
          .width  = getmaxx(win),
          .height = getmaxy(win),
      };
  }
#+END_SRC


*** Popup window example

#+BEGIN_SRC c
  void print_question_and_answer(int screen_width, int screen_height) {
      char input_char = 0;

      //
      // Clear the screen output and move cursor to init position if needed
      // clear();
      move(0, 0);

      // Create new popup windows
      const PopupWindow popup = create_popup_window(screen_width, screen_height);

      //
      // Print inside the popup window: Move cursor relative by the given window
      // and print somthing
      //
      int row_in_popup = 2;
      int col_in_popup = 4;
      mvwprintw(popup.win,
                row_in_popup,
                col_in_popup,
                "Which one is your favored OS:");

      row_in_popup++;
      mvwprintw(popup.win, row_in_popup, col_in_popup, "1. FreeBSD");

      row_in_popup++;
      mvwprintw(popup.win, row_in_popup, col_in_popup, "2. OpenBSD");

      row_in_popup++;
      mvwprintw(popup.win, row_in_popup, col_in_popup, "3. ArchLinux");
      wrefresh(popup.win);  // Draw once after all `wprintw` calls have been done.

      noecho();
      input_char = getch();

      row_in_popup += 2;

      mvwprintw(popup.win,
                row_in_popup,
                col_in_popup,
                "You choose: %c",
                input_char);
      mvwprintw(popup.win,
                row_in_popup + 2,
                col_in_popup,
                "Press any key to close the popup window.");
      wrefresh(popup.win);  // Draw once after all `wprintw` calls have been done.

      //
      // Press a key to destory the popup window
      //
      wgetch(popup.win);
      wclear(popup.win);
      wrefresh(popup.win);
      delwin(popup.win);
  } 
#+END_SRC


*** Drawing window border

You can use =box= to draw the default border or use =wboard= to draw a customized border for the given window.

#+BEGIN_SRC c
  //
  // `chtype` means a unsigned character (u32), e.g.:
  // 'a'~'z', 'A'~ Z', '0'~'9'
  // '*', '?', '>', '<', '=', etc.
  // 
  // '0' means use the default charater to fill the border!!!
  //
  box(WINDOW *win, chtype left_right, chtype top_bottom);

  int wborder(WINDOW *win,
      chtype left,
      chtype right,
      chtype top,
      chtype bottom,
      chtype top_left_corner,
      chtype top_right_corner,
      chtype bottom_left_corner,
      chtype bottom_right_corner);
#+END_SRC


#+BEGIN_SRC c
  //
  // Draw a box with default border to the given window (area)
  //
  box(w.win, 0, 0);
  wrefresh(w.win);

  //
  // Draw a custom border to the given window (area)
  //
  wborder(w.win, 'l', 'r', 't', 'b', '<', '>', '{', '}');
  wrefresh(w.win);
#+END_SRC



*** Moving cursor inside window

When calling =mvwprintw= or =wmove= with the given window, the =y,x= you pass int is related to the window itself (not the terminal screen), that said:

(0,0) - left, top
   \
   ┌──────────────────────────────────────┐
   │                                      │
   └──────────────────────────────────────┘ 
                                           \
                                           (0 + win_rect.height, 0 + win_rect.width) - bottom, right


*** Drawing performance

Here is the most important thing you need to know about the drawing performance, you can find this info by running =man curs_refresh=:


#+BEGIN_SRC bash
  wnoutrefresh/doupdate
         The wnoutrefresh and doupdate routines allow multiple updates with more efficiency than wrefresh alone.  In addition to all the window structures, curses keeps two data structures representing the terminal screen:

         •   a physical screen, describing what is actually on the screen, and

         •   a virtual screen, describing what the programmer wants to have on the screen.

         The routine wrefresh works by

         •   first calling wnoutrefresh, which copies the named window to the virtual screen, and

         •   then calling doupdate, which compares the virtual screen to the physical screen and does the actual update.

         If the programmer wishes to output several windows at once, a series of calls to wrefresh results in alternating calls to wnoutrefresh and doupdate, causing several bursts of output to the screen.  By  first  calling  wnoutrefresh
         for each window, it is then possible to call doupdate once, resulting in only one burst of output, with fewer total characters transmitted and less CPU time used.

         If the win argument to wrefresh is the physical screen (i.e., the global variable curscr), the screen is immediately cleared and repainted from scratch.

         The  phrase “copies the named window to the virtual screen” above is ambiguous.  What actually happens is that all touched (changed) lines in the window are copied to the virtual screen.  This affects programs that use overlapping
         windows; it means that if two windows overlap, you can refresh them in either order and the overlap region will be modified only when it is explicitly changed.  (But see the section on PORTABILITY below for  a  warning  about  ex‐
         ploiting this behavior.)
#+END_SRC


That said, if you want to redraw/update a few windows, you better do this instead of calling =wrefresh(win)= for each window:

#+BEGIN_SRC c
  // Draw window 1, maybe a multiple `wprintw` or `mvwprintw`
  wnoutrefresh(window1);

  // Draw window 2, maybe a multiple `wprintw` or `mvwprintw`
  wnoutrefresh(window2);

  // Draw window 3, maybe a multiple `wprintw` or `mvwprintw`
  wnoutrefresh(window3);

  // Finally, push all changes from the virtual screen to the physical screen in one shot
  doupdate();
#+END_SRC


Pay attention that: 

if you call any of these funciton: =refresh(), getch(), wrefresh(stdscr), wgetch(stdscr)=, then the screen is immediately cleared and repainted from scratch. That also broke your drawing optimization!!!
if you call any of these funciton: =refresh(), getch(), wrefresh(stdscr), wgetch(stdscr)=, then the screen is immediately cleared and repainted from scratch. That also broke your drawing optimization!!!
if you call any of these funciton: =refresh(), getch(), wrefresh(stdscr), wgetch(stdscr)=, then the screen is immediately cleared and repainted from scratch. That also broke your drawing optimization!!!


** =Video Attributes=

*** =chtype= type

Before talking about video attributes, you need to know more deeper about the =chtype=:

=chtype= is the =u32= (not a =u8=), it contains extra info more than a single ASCII char. Let' take a look at the following code:

#+BEGIN_SRC c
  chtype char_1 = 'A';
  chtype char_2 = 'A' | COLOR_PAIR(top_border_color_pair);
  chtype char_3 = 'A' | A_STANDOUT;
  chtype char_4 = 'A' | A_STANDOUT | COLOR_PAIR(top_border_color_pair);

  printf("\n>>> size of 'chtype': %lu", sizeof(chtype));
  printf("\n>>> char_1 ascii: %d, Hex: 0x%02X", char_1, char_1);
  printf("\n>>> char_2 ascii: %d, Hex: 0x%02X", char_2, char_2);
  printf("\n>>> char_3 ascii: %d, Hex: 0x%02X", char_3, char_3);
  printf("\n>>> char_4 ascii: %d, Hex: 0x%02X", char_4, char_4);
  PRINT_BITS(char_1);
  PRINT_BITS(char_2);
  PRINT_BITS(char_3);
  PRINT_BITS(char_4);
#+END_SRC

Output:

#+BEGIN_SRC bash
  >>> size of 'chtype': 4
  >>> char_1 ascii: 65, Hex: 0x41
  >>> char_2 ascii: 321, Hex: 0x141
  >>> char_3 ascii: 65601, Hex: 0x10041
  >>> char_4 ascii: 65857, Hex: 0x10141
  >>> [ PRINT_BITS ] - 0x41 bits:    0000000000000000 00000000 01000001
  >>> [ PRINT_BITS ] - 0x141 bits:   0000000000000000 00000001 01000001
  >>> [ PRINT_BITS ] - 0x10041 bits: 0000000000000001 00000000 01000001
  >>> [ PRINT_BITS ] - 0x10141 bits: 0000000000000001 00000001 01000001⏎
#+END_SRC

As you can see the result above:

=cha_1= only contains the ASCII (=0x41=) in the 1nd 8 bits (=01000001=).
=cha_2= contains the ASCII (=0x41=) in the 1nd 8 bits (=01000001=), and the color value in the 2nd 8bits(=00000001=).
=cha_3= contains the ASCII (=0x41=) in the 1nd 8 bits (=01000001=), and the attr value in the 3nd 16bits(=0000000000000001=).
=cha_4= contains all of them together.

That's how =chtype= stores rich-info character under the hood.


*** Video attributes

Attributes are a property of the character, it affects the graphic rendition of characters put on the screen.

The following video attributes, defined in =<curses.h>=, can be passed to the routines =attron=, =attroff=, and =attrset=, or OR'd with the characters passed to =addch=:

#+BEGIN_SRC bash
  Name            Description
  ─────────────────────────────────────────
  A_NORMAL       Normal display (no highlight)
  A_STANDOUT     Best highlighting mode of the terminal.
  A_UNDERLINE    Underlining
  A_REVERSE      Reverse video
  A_BLINK        Blinking
  A_DIM          Half bright
  A_BOLD         Extra bright or bold
  A_PROTECT      Protected mode
  A_INVIS        Invisible or blank mode
  A_ALTCHARSET   Alternate character set
  A_ITALIC       Italics (non-X/Open extension)
  A_CHARTEXT     Bit-mask to extract a character
  A_COLOR        Bit-mask to extract a color (legacy routines)
#+END_SRC


These video attributes are supported by =attr_on= and related functions (which also support the attributes recognized by =attron=, etc.):

#+BEGIN_SRC bash
  Name            Description
  ─────────────────────────────────────────
  WA_HORIZONTAL   Horizontal highlight
  WA_LEFT         Left highlight
  WA_LOW          Low highlight
  WA_RIGHT        Right highlight
  WA_TOP          Top highlight
  WA_VERTICAL     Vertical highlight
#+END_SRC


*** How to apply the attributes

Here is the common pattern to apply attributes to printed text:

#+BEGIN_SRC c
  wattron(win, ATTR_HERE);
  wprintw(win, ....)
  wattroff(win, ATTR_HERE);
#+END_SRC

You can =|= a couple of attributes together, here is an example:

#+BEGIN_SRC c
  wattron(stdscr, A_ITALIC | A_BOLD | A_REVERSE);
  wprintw(stdscr, "Here is the 'A_ITALIC | A_BOLD | A_REVERSE' attribute effect.\n");
  wattroff(stdscr, A_ITALIC | A_BOLD | A_REVERSE);
#+END_SRC


Of course, you're able to apply any attributes to the single =chtype= variable like this:

#+BEGIN_SRC c
  chtype char_4 = 'A' | A_STANDOUT | COLOR_PAIR(top_border_color_pair);
#+END_SRC

But keep that in mind, =char_4= only will be printed as colored and styled by calling =addch= (or related variants) but not =printw= (or related variants)!!!
But keep that in mind, =char_4= only will be printed as colored and styled by calling =addch= (or related variants) but not =printw= (or related variants)!!!
But keep that in mind, =char_4= only will be printed as colored and styled by calling =addch= (or related variants) but not =printw= (or related variants)!!!


*** How to change the applied attributes

After applying the attributes to the printed text, you can change their attributes on the fly by calling

#+BEGIN_SRC c
  wchgat (
      WINDOW *,         // WINDOW *
      int,              // How many characters to will be affected from current
                        // cursor position, `-1` means to the end of line
      attr_t,           // New attributes to override
      NCURSES_PAIRS_T,  // Color pair index
      const void *      // Set to `NULL`
  );
#+END_SRC

#+BEGIN_SRC c
  wattron(stdscr, A_ITALIC | A_BOLD | A_REVERSE);
  wprintw(stdscr, "Here is the 'A_ITALIC | A_BOLD | A_REVERSE' attribute effect.\n");
  wattroff(stdscr, A_ITALIC | A_BOLD | A_REVERSE);

  int cur_x = 0, cur_y = 0;
  getyx(stdscr, cur_y, cur_x);
        init_pair(8, COLOR_RED, COLOR_BLACK);
  wattron(stdscr, A_ITALIC | COLOR_PAIR(8));
  mvwprintw(stdscr, cur_y - 1, 1, "cur_y: %d, cur_x: %d", cur_y, cur_x);
  wattroff(stdscr, A_ITALIC | COLOR_PAIR(8));
  mvwchgat(stdscr, cur_y - 1, 0, strlen(text), A_NORMAL, 8, NULL);
#+END_SRC


** User input

*** Input options

For more details, read =man curs_inopts=.

- =noecho=: Doesn't print the pressed key.

- =cbreak=: User input available to the program immediately no need to wait for a =<CR>=, you see what typed.
- =nocbreak=: TTY driver buffers the what you typed until you press =<CR>=.

- =nl/nonl=: The =nl= and =nonl= routines control whether the underlying display device translates the return key into newline on input.

- =raw=: Same with =cbreak= except it passes through the typed key uninterpreted, that's why =<C-c>= doesn't terminate your program in =Raw Mode=!!!

- =nodelay=: The nodelay option causes getch to be a non-blocking call.  If no input is ready, getch returns ERR.  If disabled (~bf~ is FALSE), getch waits until a key is pressed.

- =timeout/wtimeout=: The =timeout= and =wtimeout= routines set blocking or non-blocking read for a given window.

  > If ~delay~ is negative, blocking read is used (i.e., waits indefinitely for input).
  > If ~delay~ is zero, then non-blocking read is used (i.e., read returns ERR if no input is waiting).
  > If ~delay~ is positive, then read blocks for delay milliseconds, and returns ERR if there is still no input.

  Hence, these routines provide the same functionality as =nodelay=, plus the additional capability of being able to block for only delay milliseconds (where ~delay~ is positive).

- =keypad (WINDOW *,bool);=: Enable number key and arrow key or not, disabled by default.
  You have to enable this if you want to capture the following keys:

  #+BEGIN_SRC c
    #define KEY_DOWN	0402		/* down-arrow key */
    #define KEY_UP	0403		/* up-arrow key */
    #define KEY_LEFT	0404		/* left-arrow key */
    #define KEY_RIGHT	0405		/* right-arrow key */
    #define KEY_HOME	0406		/* home key */
    #define KEY_F0	0410		/* Function keys.  Space for 64 */
    #define KEY_F(n)	(KEY_F0+(n))	/* Value of function key n */
    ...
  #+END_SRC


*** Related functions

#+BEGIN_SRC c
  int getch(void) // Wait for a single char from the cursor position
  int wgetch(WINDOW *win)
  int mvwgetch (WINDOW *win, int row, int col);

  int delch(void) // Delete a single char from the cursor position
  int wdelch(WINDOW *win)
  int mvwdelch (WINDOW *win, int row, int col);
#+END_SRC

Any =getch= functions will invoke =wrefresh=!!!


*** Capture modify key (Ctrl, Alt)

You got 2 ways to detected whether =Ctrl= is pressed of not:

#+BEGIN_SRC c
  uint8_t c = 0;
  while ((c = wgetch(stdscr)) != 'Q') {
      //
      // 1. Compare string with `keyname(c)`
      //
      const char *typed_key = keyname(c);
      if (strcmp(typed_key, "^A") == 0) {
          wprintw(stdscr, "You pressed: <C-A>, HEX: 0x%.2X\n", c);
      }
      //
      // 2. Like this
      //
      else if (c == ('I' & 0x1F)) {
          wprintw(stdscr, "You pressed: <C-I>, HEX: 0x%.2X\n", c);
      }
      else {
          wprintw(stdscr,
                  "You pressed: %s, HEX: 0x%.2X %s\n",
                  typed_key,
                  c,
                  typed_key[0] == '^' ? "(modify key: CTRL)" : "");
      }
  }
#+END_SRC


Full example:

#+BEGIN_SRC c
  #include <ncurses.h>
  #include <string.h>
 
  int main() {
      initscr();
      noecho();
      raw();
      keypad(stdscr, true);

      if (!has_colors() || !can_change_color()) {
          printf("\n>>> Terminal doesn't support colors");
          return -1;
      }
      start_color();

      wprintw(stdscr, "Press 'Q' key to exit:)\n\n");

      uint8_t c = 0;
      while ((c = wgetch(stdscr)) != 'Q') {
          //
          // 1. Compare string with `keyname(c)`
          //
          const char *typed_key = keyname(c);
          if (strcmp(typed_key, "^A") == 0) {
              wprintw(stdscr, "You pressed: <C-A>, HEX: 0x%.2X\n", c);
          }
          //
          // 2. Like this
          //
                  else if (c == ('I' & 0x1F)) {
              wprintw(stdscr, "You pressed: <C-I>, HEX: 0x%.2X\n", c);
          }
                  else {
              wprintw(stdscr,
                      "You pressed: %s, HEX: 0x%.2X %s\n",
                      typed_key,
                      c,
                      typed_key[0] == '^' ? "(modify key: CTRL)" : "");
          }
      }

      endwin();
      return 0;
  } 
#+END_SRC


*** Special keys you need to know

#+BEGIN_SRC c
  <TAB>  = <C-I> = 0x01
  <DOWN> = <C-B> = 0x02
  <UP>   = <C-C> = 0x03
  <LEFT> = <C-D> = 0x04
  <RIGHT>= <C-D> = 0x05
  <CR>   = <C-J> = 0x0A
#+END_SRC

Those are the special keys with the same HEX value, that's why you can't treat =<TAB>= and =<C-I>= as different keybindings, as they are equal in terminal!!! Same thing with =<C-S-A>= and =<C-A>=.


** =Color=

*** Check terminal color support and start using color

#+BEGIN_SRC c
  initscr();

  if (!has_colors() || !can_change_color())) {
      printf("\n>>> Terminal doesn't support colors");
      return -1;
  }
  start_color();

  endwin();
#+END_SRC


*** Create your own color

**** Related functions

=init_color= creates customized RGB color,
=init_pair= creates foreground and background color pair
=COLOR_PAIR= gets back the color attribute by the given color pair index

- =int init_color(short color_index, short r, short g, short b)=

- =int init_pair(color_pair_index, foreground_color_index, background_color_index)=

- =COLOR_PAIR(color_pair_index)=

After that, you can use =attron(color_attr)/wattron(win, color_attr)= and 
=attroff(color_attr)/wattroff(win, color_attr)= to wrap the =wprintw= to render color outputs.


**** HEX color (value) to short color value

In =<ncurses.h>=, you can find the following type macros:

#+BEGIN_SRC c
  #define	NCURSES_COLOR_T short
  #define	NCURSES_PAIRS_T short
#+END_SRC

That means if you use HEX as the colour value, you need the following formula to convert it into the short int colour value:

~const r = (float)((float)0xRED_COLOR_HEX_HERE / (float)256) * 1000~


**** Default color index

Here are the default =ncurses= global variables and their values:

#+BEGIN_SRC c
  wprintw(stdscr,
          "COLORS: %d\nCOLORS_PAIRS: %d\n\nCOLOR_BLACK: %d\nCOLOR_RED: "
          "%d\nCOLOR_GREEN: %d\nCOLOR_YELLOW: %d\nCOLOR_BLUE: "
          "%d\nCOLOR_MAGENTA: %d\nCOLOR_CYAN: %d\nCOLOR_WHITE: %d\n",
                      COLORS,
                      COLOR_PAIRS,
          COLOR_BLACK,
          COLOR_RED,
          COLOR_GREEN,
          COLOR_YELLOW,
          COLOR_BLUE,
          COLOR_MAGENTA,
          COLOR_CYAN,
          COLOR_WHITE);
#+END_SRC


Output:

#+BEGIN_SRC bash
  COLORS: 256
  COLORS_PAIRS: 65536

  COLOR_BLACK: 0
  COLOR_RED: 1
  COLOR_GREEN: 2
  COLOR_YELLOW: 3
  COLOR_BLUE: 4
  COLOR_MAGENTA: 5
  COLOR_CYAN: 6
  COLOR_WHITE: 7
#+END_SRC

That's why you're only allowed to create no longer than =(256 - 8)= custom colours, and your customized colour index should start from =9= (as =0 ~ 8= is used for the predefined colours)!!!


**** Example

#+BEGIN_SRC c
  #include <ncurses.h>

  #define CUSTOM_COLOR_START_INDEX 9

  int main() {
      initscr();

      if (!has_colors()) {
          printf("\n>>> Terminal doesn't support colors");
          return -1;
      }
      start_color();

      //
      // Create your own color
      //
      short color_index                  = CUSTOM_COLOR_START_INDEX;
      const short foreground_color_index = color_index;
      init_color(foreground_color_index,
                 (float)((float)0xF4 / (float)256) * 1000,
                 (float)((float)0x47 / (float)256) * 1000,
                 (float)((float)0x47 / (float)256) * 1000);
      color_index += 1;

      const short background_color_index = color_index;
      init_color(background_color_index,
                 (float)((float)0x23 / (float)256) * 1000,
                 (float)((float)0x21 / (float)256) * 1000,
                 (float)((float)0x1B / (float)256) * 1000);
      color_index += 1;

      const short my_color_pair_index = 1;
      init_pair(my_color_pair_index,
                foreground_color_index,
                background_color_index);
      const short selected_color_attr = COLOR_PAIR(my_color_pair_index);

      //
      // Use selected color to draw
      //
      wattron(stdscr, selected_color_attr);
      wprintw(stdscr, "Here is the selected color:)");
      wattroff(stdscr, selected_color_attr);

      // Press any key to exit.
      getch();
      endwin();
      return 0;
  }
#+END_SRC


*** Color theme

Here is the color theme example:

**** =color.h=

#+BEGIN_SRC c
  #include <ncurses.h>

  #define COLOR_PAIR_SIZE 10
  #define CUSTOMIZE_COLOR_START_INDEX 9
  #define CUSTOMIZE_COLOR_PAIR_START_INDEX 1

  // `NCURSES_COLOR_T` -> `short`

  typedef struct Color {
      NCURSES_COLOR_T r;
      NCURSES_COLOR_T g;
      NCURSES_COLOR_T b;
  } Color;

  typedef struct ColorPair {
      // This usesd for `init_pair`
      NCURSES_COLOR_T color_pair_index;
      // Not useful, just for debugging
      NCURSES_COLOR_T foreground_color_index;
      NCURSES_COLOR_T background_color_index;

      const char *name;
      Color foreground;
      Color background;
  } ColorPair;

  typedef struct ColorTheme {
      const char *name;
      ColorPair pairs[COLOR_PAIR_SIZE];

  } ColorTheme;

  ColorTheme CT_init();
#+END_SRC


**** =color.c=

#+BEGIN_SRC c
  #include "color.h"

  #include <ncurses.h>

  ColorTheme CT_init() {
      short temp_color_index      = CUSTOMIZE_COLOR_START_INDEX;
      short temp_color_pair_index = CUSTOMIZE_COLOR_PAIR_START_INDEX;

      ColorTheme self = (ColorTheme){
          .name = "TronLegacy",
          .pairs =
              {
                  (ColorPair){
                      .color_pair_index       = -1,
                      .foreground_color_index = -1,
                      .background_color_index = -1,
                      .name                   = "Tron Red",
                      .foreground =
                          (Color){
                              .r = (float)((float)0xF4 / (float)256) * 1000,
                              .g = (float)((float)0x47 / (float)256) * 1000,
                              .b = (float)((float)0x47 / (float)256) * 1000,
                          },
                      .background =
                          (Color){
                              .r = (float)((float)0x23 / (float)256) * 1000,
                              .g = (float)((float)0x21 / (float)256) * 1000,
                              .b = (float)((float)0x1B / (float)256) * 1000,
                          },
                  },
                  (ColorPair){
                      .color_pair_index       = -1,
                      .foreground_color_index = -1,
                      .background_color_index = -1,
                      .name                   = "Tron Orange",
                      .foreground =
                          (Color){
                              .r = (float)((float)0xFF / (float)256) * 1000,
                              .g = (float)((float)0x9F / (float)256) * 1000,
                              .b = (float)((float)0x1C / (float)256) * 1000,
                          },
                      .background =
                          (Color){
                              .r = (float)((float)0x23 / (float)256) * 1000,
                              .g = (float)((float)0x21 / (float)256) * 1000,
                              .b = (float)((float)0x1B / (float)256) * 1000,
                          },
                  },
                  (ColorPair){
                      .color_pair_index       = -1,
                      .foreground_color_index = -1,
                      .background_color_index = -1,
                      .name                   = "Tron Blue",
                      .foreground =
                          (Color){
                              .r = (float)((float)0x6F / (float)256) * 1000,
                              .g = (float)((float)0xC3 / (float)256) * 1000,
                              .b = (float)((float)0xDF / (float)256) * 1000,
                          },
                      .background =
                          (Color){
                              .r = (float)((float)0x23 / (float)256) * 1000,
                              .g = (float)((float)0x21 / (float)256) * 1000,
                              .b = (float)((float)0x1B / (float)256) * 1000,
                          },
                  },
                  (ColorPair){
                      .color_pair_index       = -1,
                      .foreground_color_index = -1,
                      .background_color_index = -1,
                      .name                   = "Tron Yellow",
                      .foreground =
                          (Color){
                              .r = (float)((float)0xFF / (float)256) * 1000,
                              .g = (float)((float)0xE6 / (float)256) * 1000,
                              .b = (float)((float)0x4D / (float)256) * 1000,
                          },
                      .background =
                          (Color){
                              .r = (float)((float)0x23 / (float)256) * 1000,
                              .g = (float)((float)0x21 / (float)256) * 1000,
                              .b = (float)((float)0x1B / (float)256) * 1000,
                          },
                  },
              },
      };

      for (int index = 0; index < COLOR_PAIR_SIZE; index++) {
          //
          // `init_color` creates RGB color
          //
          // init_color(color_index, r, g, b)
          //
          const short foreground_color_index = temp_color_index;
          init_color(foreground_color_index,
                     self.pairs[index].foreground.r,
                     self.pairs[index].foreground.g,
                     self.pairs[index].foreground.b);
          self.pairs[index].foreground_color_index = foreground_color_index;
          temp_color_index += 1;

          const short background_color_index = temp_color_index;
          init_color(background_color_index,
                     self.pairs[index].background.r,
                     self.pairs[index].background.g,
                     self.pairs[index].background.b);
          self.pairs[index].background_color_index = background_color_index;
          temp_color_index += 1;

          //
          // `init_pair` creates foreground and background color pair
          //
          // init_pair(color_pair_index, foreground_color_index, background_color_index)
          //
          init_pair(temp_color_pair_index,
                    foreground_color_index,
                    background_color_index);
          self.pairs[index].color_pair_index = temp_color_pair_index;
          temp_color_pair_index += 1;
      }

      return self;
  }
#+END_SRC


**** =main.c=

#+BEGIN_SRC c
   #include <ncurses.h>

   int main() {
      initscr();

      if (!has_colors()) {
          printf("\n>>> Terminal doesn't support colors");
          return -1;
      }
      start_color();

      ColorTheme theme = CT_init();
      mvwprintw(stdscr, 0, 0, "Loaded color theme: %s", theme.name);

      move(2, 0);
      // for (int index = 0; index < COLOR_PAIR_SIZE; index++) {
      for (int index = 0; index < 4; index++) {
          const ColorPair *cp        = &theme.pairs[index];
          const short selected_color = COLOR_PAIR(cp->color_pair_index);
          attron(selected_color);

          wprintw(
              stdscr,
              "[ Color pair name ] {\n\tname: %s\n\tcp_index: "
              "%d\n\tforeground_color_index: %d\n\t"
              "background_color_index: %d\n\tforeground: {\n\t\tr: %d\n\t\tg: "
              "%d\n\t\tb: %d\n\t}\n}\n",
              cp->name,
              cp->color_pair_index,
              cp->foreground_color_index,
              cp->background_color_index,
              cp->foreground.r,
              cp->foreground.g,
              cp->foreground.b);

          attroff(selected_color);
      }

      // Press any key to exit.
      getch();
      endwin();
      return 0;
  } 
#+END_SRC



** Show and hide cursor

#+BEGIN_SRC hare
  //
  // Cursor option
  //
  export def CURSOR_INVISIBLE: int = 0;
  export def CURSOR_NORMAL: int = 1;
  export def CURSOR_VERY_VISIBLE: int = 2;

  @symbol("curs_set") fn curs_set(int) int;
  export fn hide_cursor() int = curs_set(CURSOR_INVISIBLE);
  export fn show_cursor() int = curs_set(CURSOR_NORMAL);
  export fn show_cursor_2() int = curs_set(CURSOR_VERY_VISIBLE);
#+END_SRC
